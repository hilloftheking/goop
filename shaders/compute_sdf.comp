#version 430 core

#include "../src/blob_defines.h"

layout(local_size_x = BLOB_SDF_LOCAL_GROUPS, local_size_y = BLOB_SDF_LOCAL_GROUPS, local_size_z = BLOB_SDF_LOCAL_GROUPS) in;

layout(std430, binding = 0) restrict readonly buffer Blobs {
  vec4[] blobs;
};

layout(std430, binding = 1) restrict readonly buffer BlobOctree {
  int[] blob_ot;
};

layout(rgba8, binding = 0) writeonly uniform image3D img_output;

layout(location = 0) uniform ivec3 invocation_offset;

vec3 colors[] = {
  vec3(BLOB_COL_LIQUID),
  vec3(BLOB_COL_SOLID),
  vec3(BLOB_COL_CHAR)
};

float smin(float a, float b, float k) {
  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

float dist_sphere(vec3 c, float r, vec3 p) {
  return length(p - c) - r;
}

float dist_cube(vec3 c, float s, vec3 p) {
  vec3 d = abs(p - c) - vec3(s * 0.5);
  return length(max(d, 0.0));
}

void main() {
  vec3 p =
      (vec3(invocation_offset) + vec3(gl_GlobalInvocationID) + vec3(0.5)) * (vec3(BLOB_SDF_SIZE) / BLOB_SDF_RES) +
      vec3(BLOB_SDF_START);
  
  const vec3 ot_quadrants[8] = {vec3(0.5f, 0.5f, 0.5f),   vec3(0.5f, 0.5f, -0.5f),
                               vec3(0.5f, -0.5f, 0.5f),  vec3(0.5f, -0.5f, -0.5f),
                               vec3(-0.5f, 0.5f, 0.5f),  vec3(-0.5f, 0.5f, -0.5f),
                               vec3(-0.5f, -0.5f, 0.5f), vec3(-0.5f, -0.5f, -0.5f)};
  
  vec3 node_pos = vec3(BLOB_SDF_START) + vec3(BLOB_SDF_SIZE) * 0.5;
  float node_size = vec3(BLOB_SDF_SIZE).x;
  int node_idx = 0;
  int node_leaf_blob_count = blob_ot[node_idx];
  while (node_leaf_blob_count == -1) {
    bool found_intersection = false;

    for (int i = 0; i < 8; i++) {
      vec3 child_pos = node_pos + vec3(node_size) * ot_quadrants[i] * 0.5;
      float child_size = node_size * 0.5;

      if (dist_cube(child_pos, child_size, p) <= 0.0) {
        node_pos = child_pos;
        node_size = child_size;
        node_idx = blob_ot[node_idx + 1 + i];
        node_leaf_blob_count = blob_ot[node_idx];
        found_intersection = true;
        break;
      }
    }

    if (!found_intersection) {
      break;
    }
  }

  float value = 1000.0;
  vec3 color = vec3(0.0);

  for (int i = 0; i < node_leaf_blob_count; i++) {
    int blob_idx = blob_ot[node_idx + 1 + i];
    vec4 blob = blobs[blob_idx];

    float d = dist_sphere(blob.xyz, BLOB_RADIUS, p);
    float old_val = value;
    value = smin(value, d, BLOB_SMOOTH);

    float diff = old_val - value;
    color = mix(color, colors[int(blob.a)], clamp(diff / BLOB_COLOR_BLEND, 0.0, 1.0));
  }

  //value = min(BLOB_SDF_MAX_DIST, value);

  value = clamp(value, -0.5, BLOB_SDF_MAX_DIST);

  imageStore(img_output, invocation_offset + ivec3(gl_GlobalInvocationID.xyz),
             vec4(color, (value + 0.5) / (BLOB_SDF_MAX_DIST + 0.5)));
}