#version 430 core

#include "../src/blob_defines.h"

layout(local_size_x = BLOB_SDF_LOCAL_GROUPS, local_size_y = BLOB_SDF_LOCAL_GROUPS, local_size_z = BLOB_SDF_LOCAL_GROUPS) in;

layout(std430, binding = 0) restrict readonly buffer Blobs {
  vec4 blobs[];
};

layout(std430, binding = 1) restrict readonly buffer BlobOctree {
  int blob_ot[];
};

layout(rgba8, binding = 0) writeonly uniform image3D img_output;

layout(location = 0) uniform int blob_count; // If this is -1, an octree is used
layout(location = 1) uniform vec3 sdf_size;
layout(location = 2) uniform vec3 sdf_start;

vec3 colors[BLOB_MAT_COUNT] = {
  vec3(BLOB_COL_LIQUID),
  vec3(BLOB_COL_SOLID),
  vec3(0.850, 0.767, 0.136), // yellow
  vec3(0.940, 0.561, 0.0658), // orange
  vec3(0.150, 0.0850, 0.00) // black
};

float smin(float a, float b, float k) {
  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

float dist_sphere(vec3 c, float r, vec3 p) {
  return length(p - c) - r;
}

float dist_cube(vec3 c, float s, vec3 p) {
  vec3 d = abs(p - c) - vec3(s * 0.5);
  return length(max(d, 0.0));
}

void main() {
  bool use_octree = blob_count == -1;

  vec3 p =
      (vec3(gl_GlobalInvocationID) + vec3(0.5)) * (sdf_size / BLOB_SDF_RES) +
      sdf_start;
  
  const vec3 ot_quadrants[8] = {vec3(0.5f, 0.5f, 0.5f),   vec3(0.5f, 0.5f, -0.5f),
                               vec3(0.5f, -0.5f, 0.5f),  vec3(0.5f, -0.5f, -0.5f),
                               vec3(-0.5f, 0.5f, 0.5f),  vec3(-0.5f, 0.5f, -0.5f),
                               vec3(-0.5f, -0.5f, 0.5f), vec3(-0.5f, -0.5f, -0.5f)};
  
  vec3 node_pos;
  float node_size;
  int node_idx, node_leaf_blob_count;
  if (use_octree) {
    node_pos = sdf_start + sdf_size * 0.5;
    node_size = sdf_size.x;
    node_idx = 0;
    node_leaf_blob_count = blob_ot[node_idx];
    while (node_leaf_blob_count == -1) {
      bool found_intersection = false;

      for (int i = 0; i < 8; i++) {
        vec3 child_pos = node_pos + vec3(node_size) * ot_quadrants[i] * 0.5;
        float child_size = node_size * 0.5;

        if (dist_cube(child_pos, child_size, p) <= 0.0) {
          node_pos = child_pos;
          node_size = child_size;
          node_idx = blob_ot[node_idx + 1 + i];
          node_leaf_blob_count = blob_ot[node_idx];
          found_intersection = true;
          break;
        }
      }

      if (!found_intersection) {
        break;
      }
    }
  }

  float value = 1000.0;
  vec3 color = vec3(0.0);

  int count;
  if (use_octree) {
    count = node_leaf_blob_count;
  } else {
    count = blob_count;
  }

  for (int i = 0; i < count; i++) {
    vec4 blob;
    if (use_octree) {
      int blob_idx = blob_ot[node_idx + 1 + i];
      blob = blobs[blob_idx];
    } else {
      blob = blobs[i];
    }

    int mat_idx = int(blob.a) % BLOB_MAT_COUNT;
    float radius = (int(blob.a) / BLOB_MAT_COUNT) / float(BLOB_RADIUS_MULT);

    float d = dist_sphere(blob.xyz, radius, p);
    float old_val = value;
    value = smin(value, d, BLOB_SMOOTH);

    float diff = old_val - value;
    color = mix(color, colors[mat_idx], clamp(diff / BLOB_COLOR_BLEND, 0.0, 1.0));
  }

  value = clamp(value, -0.5, BLOB_SDF_MAX_DIST);

  imageStore(img_output, ivec3(gl_GlobalInvocationID.xyz),
             vec4(color, 1.0 - (value + 0.5) / (BLOB_SDF_MAX_DIST + 0.5)));
}