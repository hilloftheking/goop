#version 430

#include "../src/blob_defines.h"

layout(local_size_x = BLOB_SDF_LOCAL_GROUP_COUNT, local_size_y = BLOB_SDF_LOCAL_GROUP_COUNT, local_size_z = BLOB_SDF_LOCAL_GROUP_COUNT) in;

layout(std430, binding = 0) restrict readonly buffer Blobs {
  vec4 blobs[];
};

layout(std430, binding = 1) restrict readonly buffer BlobOctree {
  int blob_ot[];
};

layout(rgba8, binding = 0) writeonly uniform image3D img_output;

layout(location = 0) uniform int blob_count; // If this is -1, an octree is used
layout(location = 1) uniform vec3 sdf_pos;
layout(location = 2) uniform float sdf_size;
layout(location = 3) uniform int sdf_res;
layout(location = 4) uniform float sdf_max_dist;
layout(location = 5) uniform float blob_smooth;

vec3 colors[BLOB_MAT_COUNT] = {
  vec3(0.41, 0.04, 0.06), // red
  vec3(0.49, 0.8, 0.2), // green
  vec3(0.850, 0.767, 0.136), // yellow
  vec3(0.940, 0.561, 0.0658), // orange
  vec3(0.150, 0.0850, 0.00), // black
  vec3(0.505, 0.706, 0.870), // blue
  vec3(0.9, 0.9, 0.8) // white
};

float smin(float a, float b, float k) {
  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

float dist_sphere(vec3 c, float r, vec3 p) {
  return length(p - c) - r;
}

float dist_cube(vec3 c, float s, vec3 p) {
  vec3 d = abs(p - c) - vec3(s * 0.5);
  return length(max(d, 0.0));
}

void main() {
  bool use_octree = blob_count == -1;

  vec3 p =
      (vec3(gl_GlobalInvocationID) + vec3(0.5)) * (sdf_size / sdf_res) +
      sdf_pos - vec3(sdf_size) * 0.5;
  
  const vec3 ot_quadrants[8] = {vec3(0.5f, 0.5f, 0.5f),   vec3(0.5f, 0.5f, -0.5f),
                               vec3(0.5f, -0.5f, 0.5f),  vec3(0.5f, -0.5f, -0.5f),
                               vec3(-0.5f, 0.5f, 0.5f),  vec3(-0.5f, 0.5f, -0.5f),
                               vec3(-0.5f, -0.5f, 0.5f), vec3(-0.5f, -0.5f, -0.5f)};
  
  vec3 node_pos;
  float node_size;
  int node_idx, node_leaf_blob_count;
  if (use_octree) {
    node_pos = sdf_pos;
    node_size = sdf_size;
    node_idx = 0;
    node_leaf_blob_count = blob_ot[node_idx];
    while (node_leaf_blob_count == -1) {
      bool found_intersection = false;

      for (int i = 0; i < 8; i++) {
        vec3 child_pos = node_pos + vec3(node_size) * ot_quadrants[i] * 0.5;
        float child_size = node_size * 0.5;

        if (dist_cube(child_pos, child_size, p) <= 0.0) {
          node_pos = child_pos;
          node_size = child_size;
          node_idx += blob_ot[node_idx + 1 + i];
          node_leaf_blob_count = blob_ot[node_idx];
          found_intersection = true;
          break;
        }
      }

      if (!found_intersection) {
        break;
      }
    }
  }

  float value = 1000.0;

  float color_total_influence = 0.0;
  vec3 color = vec3(0.0);

  int count;
  if (use_octree) {
    count = node_leaf_blob_count;
  } else {
    count = blob_count;
  }

  for (int i = 0; i < count; i++) {
    vec4 blob;
    if (use_octree) {
      int blob_idx = blob_ot[node_idx + 1 + i];
      blob = blobs[blob_idx];
    } else {
      blob = blobs[i];
    }

    int mat_idx = int(blob.a) % BLOB_MAT_COUNT;
    float radius = (int(blob.a) / BLOB_MAT_COUNT) / float(BLOB_RADIUS_MULT);

    float d = dist_sphere(blob.xyz, radius, p);
    value = smin(value, d, blob_smooth);

    // TODO: this will break if a bunch of blobs are stacked
    float color_influence = clamp(blob_smooth - d, 0.0, 1.0);
    color_influence *= color_influence;
    color_total_influence += color_influence;
    color += colors[mat_idx] * color_influence;
  }

  value = clamp(value, BLOB_SDF_MIN_DIST, sdf_max_dist);
  color /= color_total_influence;

  imageStore(img_output, ivec3(gl_GlobalInvocationID.xyz),
             vec4(color, 1.0 - (value - BLOB_SDF_MIN_DIST) / (sdf_max_dist - BLOB_SDF_MIN_DIST)));
}